package xyz.viveks.simpledb.operators;

import com.google.common.base.Preconditions;
import java.util.*;
import xyz.viveks.simpledb.*;

/** The Join operator implements the relational join operation. */
public class Join extends Operator {

  private static final long serialVersionUID = 1L;

  private JoinPredicate joinPredicate;
  private OpIterator childOperator1;
  private OpIterator childOperator2;
  private Tuple tuple1;
  private Tuple tuple2;

  /**
   * Constructor. Accepts two children to join and the predicate to join them on
   *
   * @param p The predicate to use to join the children
   * @param child1 Iterator for the left(outer) relation to join
   * @param child2 Iterator for the right(inner) relation to join
   */
  public Join(JoinPredicate p, OpIterator child1, OpIterator child2) {
    this.joinPredicate = p;
    this.childOperator1 = child1;
    this.childOperator2 = child2;
  }

  public JoinPredicate getJoinPredicate() {
    return joinPredicate;
  }

  /** @return the field name of join field1. Should be quantified by alias or table name. */
  public String getJoinField1Name() {
    return childOperator1.getTupleDesc().getFieldName(joinPredicate.getField1());
  }

  /** @return the field name of join field2. Should be quantified by alias or table name. */
  public String getJoinField2Name() {
    return childOperator2.getTupleDesc().getFieldName(joinPredicate.getField2());
  }

  /** @see TupleDesc#merge(TupleDesc, TupleDesc) for possible implementation logic. */
  public TupleDesc getTupleDesc() {
    return TupleDesc.merge(childOperator1.getTupleDesc(), childOperator2.getTupleDesc());
  }

  public void open() throws DbException, NoSuchElementException, TransactionAbortedException {
    super.open();
    this.childOperator1.open();
    this.childOperator2.open();
  }

  public void close() {
    this.childOperator1.close();
    this.childOperator2.close();
    super.close();
  }

  public void rewind() throws DbException, TransactionAbortedException {
    close();
    open();
  }

  /**
   * Returns the next tuple generated by the join, or null if there are no more tuples. Logically,
   * this is the next tuple in r1 cross r2 that satisfies the join predicate. There are many
   * possible implementations; the simplest is a nested loops join.
   *
   * <p>Note that the tuples returned from this particular implementation of Join are simply the
   * concatenation of joining tuples from the left and right relation. Therefore, if an equality
   * predicate is used there will be two copies of the join attribute in the results. (Removing such
   * duplicate columns can be done with an additional projection operator if needed.)
   *
   * <p>For example, if one tuple is {1,2,3} and the other tuple is {1,5,6}, joined on equality of
   * the first column, then this returns {1,2,3,1,5,6}.
   *
   * @return The next matching tuple.
   * @see JoinPredicate#filter
   */
  protected Tuple fetchNext() throws TransactionAbortedException, DbException {
    if (tuple1 == null && childOperator1.hasNext()) {
      tuple1 = childOperator1.next();
    }

    if (tuple2 == null && childOperator2.hasNext()) {
      tuple2 = childOperator2.next();
    }

    if (tuple1 == null | tuple2 == null) {
      return null;
    }

    boolean matched = false;
    while (tuple1 != null && tuple2 != null) {
      matched = joinPredicate.filter(tuple1, tuple2);
      if (!matched) {
        forwardTuples();
      } else {
        break;
      }
    }

    if (matched) {
      Tuple joinedTuple = new Tuple(getTupleDesc());
      Iterator<Field> tuple1fields = tuple1.fields();
      int i = 0;
      while (tuple1fields.hasNext()) {
        joinedTuple.setField(i, tuple1fields.next());
        i++;
      }
      Iterator<Field> tuple2fields = tuple2.fields();
      while (tuple2fields.hasNext()) {
        joinedTuple.setField(i, tuple2fields.next());
        i++;
      }

      // forward to next tuple to be compared
      // forward chioldoperator2 first
      forwardTuples();
      return joinedTuple;
    }
    return null;
  }

  private void forwardTuples() throws DbException, TransactionAbortedException {
    if (childOperator2.hasNext()) {
      tuple2 = childOperator2.next();
    } else if (childOperator1.hasNext()) {
      tuple1 = childOperator1.next();
      childOperator2.rewind();
      tuple2 = childOperator2.next();
    } else {
      tuple1 = null;
      tuple2 = null;
    }
  }

  @Override
  public OpIterator[] getChildren() {
    return new OpIterator[] {childOperator1, childOperator2};
  }

  @Override
  public void setChildren(OpIterator[] children) {
    Preconditions.checkArgument(children.length == 2, "Has to have exactly 2 child operators");
    this.childOperator1 = children[0];
    this.childOperator2 = children[1];
  }
}
